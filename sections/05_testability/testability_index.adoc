= Testabilité
include::../../_inc_context.adoc[]
ifndef::imagesdir[]
:imagesdir: ../../
endif::[]

// tag::content[]

[.start.background]
[.center]
== Améliorer la testabilité




=== L'immobilisation par la peur

* La peur de tout casser.
** => Premier frein au changement

image::images/break_everything.gif[]

Aucune évolution n'est possible, à un rythme _soutenable_ sans confiance.

=== Le complexe de Frankenstein

Nous sommes tellement heureux d'avoir un code qui fonctionne assemblant des lignes de code sans cohérence

image::images/frankenstein_0.gif[alt]


=== Le complexe de Frankenstein

\... que nous ne voyons que trop tard que le code nous échappe totalement

image::images/frankenstein_1.gif[alt]

== La pierre philosophale

[quote, Kent Beck]
____
Tests are the Programmer's stone, transmuting fear into boredom.
____

=== Definition de la Testabilité

[quote]
____
La testabilité d'un module est la facilité à créer une série de tests automatisés.
____

* Qualité Logicielle
** Une des caractéristiques de la _Maintenabilité_

== L'échec comme premier pas.

Dans la philosophe des tests, l'échec n'est pas négatif, c'est sa persistence qu'il l'est éventuellement.

L'échec indique qu'un état souhaité n'est pas atteint. L'objectif est de l'atteindre

=== Cycle de vie > Développement Normal


[.center]
image::images/pytest-lifecycle.png[]

=== Cycle de vie > Bug fix

[.center]
image::images/pytest-bugfix-lifecycle.png[]

=== Le TDD et refactoring

* Test Driven Development
** Approche érigée en philosophie

[.center]
image::images/pytest-tdd-lifecycle.png[]

[quote,Kent Beck]
____
"Code that isn't tested doesn't work - this seems to be the safe assumption."
____


=== Testabilité, conception et confiance

[.left-column]
[.center]
--
Cercle vertueux

image::images/testability-cercle-vertueux.svg[]

--

[%step]
[.right-column]
[.center]
--
Cercle vicieux

image::images/testability-cercle-vicieux.svg[]
--

[%step]
[.reset-column.center]
--
[quote]
____
"Réalisez les projets avec des personnes motivées. Fournissez-leur l'environnement et le soutien dont elles ont besoin et _faites-leur confiance_ pour atteindre les objectifs fixés."
____
--

[NOTE.notes]
--
Il y a une relation très claire entre la conception, la testabilité et la confiance que nous plaçons dans le code.
Cette confiance agit directement sur notre motivation, notre engagement sur le projet lui-même.

La motivation est un principe très fort dans l'agilité. L'un de ces principes n'est-il pas ?

____
Réalisez les projets avec des personnes motivées. Fournissez-leur l'environnement et le soutien dont elles ont besoin et _faites-leur confiance_ pour atteindre les objectifs fixés.
____
--

=== La testabilité et qualité de conception

* Si un code est mal conçu, il est difficile à tester
* La réciproque n'est pas toujours vraie


== Test facile

[.big]
[source,python]
-----
def filter_info_log(logs: List[Log]) -> List[Log]:
    return [log for log in logs if log.level == "INFO"]
-----

[.left-column]
--

[.big]
[source,python]
-----
def test_filter_info_log_empty():
    # Given
    logs = []

    # When
    result = filter_info_log(logs)

    # Then
    assert result == []
-----
--


[.right-column]
--
[.big]
[source,python]
-----
def test_filter_info_log_no_info_logs():
    # Given
    logs = [Log(level="ERROR")]

    # When
    result = filter_info_log(logs)

    # Then
    assert result == []
-----
--

=== Test moins facile

TODO Faire un accès statique 

[.big]
[source,python,attributes]
-----
class LogFilter:
    def __init__(self, rules: Rules):
        self.rules = rules
    
    def filter_info_log(self, logs: List[Log]) -> List[Log]:
        return [log for log in logs if self.rules.validate(log, "INFOS")]
-----

[.left-column]
--
[.big]
[source,python]
-----
def test_filter_info_log_empty():
    # Given
    logs = []
    rules = Rules()
    log_filter = LogFilter(rules)

    # When
    result = log_filter.filter_info_log(logs)

    # Then
    assert result == []
-----
--


[.right-column]
--
[.big]
[source,python]
-----
def test_filter_info_log_no_info_logs():
    # Given
    logs = [Log(level="ERROR")]
    rules = Rules()
    log_filter = LogFilter(rules)

    # When
    result = log_filter.filter_info_log(logs)

    # Then
    assert result == []
-----
--



=== Test franchement pas facile

TODO inclure la connection de la base de données dans le filtre 

[.big]
[source,python,attributes]
-----
class LogFilter:
    def __init__(self, rules: Rules):
        self.rules = rules
    ...

class Rules:
    def __init__(self, db_name: str, db_host: str, db_login: str, db_password: str):
        self. conn = psycopg2.connect(database = db_name, 
                                        user = db_login, 
                                        host= db_host,
                                        password = db_password)

        self.load_rules(self.conn)
-----

[.left-column]
--
[.big]
[source,python]
-----
def test_filter_info_log_empty():
    # Given
    conn = psycopg2.connect(database = TEST_DATABASE, 
                            user = TEST_USER, 
                            host= TEST_HOST,
                            password = TEST_PASSWORD,
                            port = 5432)
    clear_then_load_rules_in_database(conn)

    logs = []
    rules = Rules(conn)
    log_filter = LogFilter(rules)

    # When
    result = log_filter.filter_info_log(logs)

    # Then
    assert result == []
-----
--


[.right-column]
--
[.big]
[source,python]
-----
def test_filter_info_log_no_info_logs():
    # Given
    conn = psycopg2.connect(database = TEST_DATABASE, 
                            user = TEST_USER, 
                            host= TEST_HOST,
                            password = TEST_PASSWORD,
                            port = 5432)
    clear_then_load_rules_in_database(conn)

    logs = [Log(level="ERROR")]
    rules = Rules(conn)
    log_filter = LogFilter(rules)

    # When
    result = log_filter.filter_info_log(logs)

    # Then
    assert result == []
-----
--

=== Facilité et couplage

[.left-column]
--
[%step]
* Coupable couplage
** Mise en condition => beaucoup de travail
*** => instanciation de nombreux objets
* Objectifs
** => Découpler au maximum
*** Conception _propre_
** => Se libérer des dépendances
*** Plusieurs stratégies
--

[.right-column]
--
[%step]
* Action préventives 
** => Nouveau code  -> nouveau test
* Action correctives
** => Legacy code
--

== Legacy et théorie

[quote,Michael C. Feathers]
____
Code without tests is bad code. It doesn't matter how well written it is; it doesn't mat-
ter how pretty or object-oriented or well-encapsulated it is. With tests, we can change
the behavior of our code quickly and verifiably. Without them, we really don't know
if our code is getting better or worse.
____

=== Le cercle infernale

[.center]
image::images/testability-cercle.svg[alt]

=== Obstacles à la testabilité

* La mise en oeuvre demande des ressources considérables qui vont au delà des moyen du développeur
** Monter une base de données, un site extérieur
* Les tests ne sont pas répétables car ils dépendent de choses qui sont trop fluctuantes
** Heure, propriétés système, randomisation
* Je ne peux rien observer

=== Chirurgie de guerre 

TBD
Il faut tester ! 

* mettre une variable témoin 
* abandonner la pureté du modèle pour capter le comportement 

=== Tests de caractérisation 

TBD

=== Raison de la difficulté à tester

* La dépendance irritante
* L'instanciation cachée
* Le Singleton
* Les boucles imbriquées 

TBC 

=== Mocking

Un mot sur les mock

Dire puissance mais parfois cache misère. 

Quand même mocker devient compliqué, c'est qu'il y a un problème de conception. 

TBD 

Le mocking ou la paresse Harry Potter -> solution pirouette cacahuète qui permet de s'en sortir quand tout est mal goupillé. 

=== Le paramètre irritant

[source,python]
----
class Validator:

    def __init__(self, conn: connection)
        """
        :param conn: psycopg2 connection
        """
        ...

    def validate(self, msg: Message):
        ...
    def load_rules(self, conn: connection):
        ...
----

=== Test lourd à faire

[source,python]
----
def test_validator_load_rules():
    # Given
    conn = psycopg2.connect(database = TEST_DATABASE, 
                            user = TEST_USER, 
                            host= TEST_HOST,
                            password = TEST_PASSWORD,
                            port = 5432)
    clear_then_load_rules_in_database(conn)

    validator = Validator(conn=conn)
    message = Message(id=123, content=f'CONTACT server=nowhere.com')


    # When
    is_valid = validator.validate(msg)


    # Then
    assert is_valid
----


== La dépendance cachée

[source,python]
----
class RadioCommunicator(Communicator):

    def __init__(self):
        self.transmitter = XBandTransmitter()

    def send(msg: Message) -> None: 
        if not self.check_compliance_with_very_complicated_rules(msg):
            return

        channel: XBandChannel = self.transmitter.get_channel()
        channel.write(Message.to_base68(msg))
        channel.close()

    def receive(self) -> Message:
        channel: XBandChannel = self.transmitter.get_channel()
        content = channel.read()
        if content :
            return Message.from_base68(content)
        channel.close()
----

Comment faire un test de `RadioCommunicator` alors que tout repose sur `XBandTransmitter` ?

== La dépendance cachée : le problème

La dépendance cachée traduit un problème de conception qui concerne l'initialisation des objet.
La dépendance cachée peut créer de sérieux problèmes de test, car nous ne savons pas forcément, en tant que concepteur du `RadioCommunicator` tout ce que cela implique.
L'autre problème concerne la connaissance, donc le coupage inhérent à cette dépendance cachée.

Le mieux est de reposer que l'abstraction plutôt que l'implémentation.

== La dépendance cachée : extraire l'interface du XBandTransmitter

Le XBandTransmitter semble manifestement se limiter à obtenir  un `Channel`
Le XBandChannel se limite lui à écrire, lire et se fermer.


Écrivons donc une interface `RadioTransmitter` et une interface `Channel`

[.left-column]
--
[source,python]
----
class Channel(Protocol):
    def write(self, content: str): 
        ...
    def read(self) -> str :
        ...
    def close(self):
        ...

class RadioTransmitter(Protocol):
    def get_channel(self) -> Channel:
        ...
----
--

[.right-column]
--
[source,python]
----
class RadioCommunicator(Communicator):

    def __init__(self):
        self.transmitter: RadioTransmitter = XBandTransmitter()

    def send(msg: Message) -> None: 
        if not self.check_compliance_with_very_complicated_rules(msg):
            return

        channel: Channel = self.transmitter.get_channel()
        channel.write(Message.to_base68(msg))
        channel.close()

    def receive(self) -> Message:
        channel: Channel = self.transmitter.get_channel()
        content = channel.read()
        if content :
            return Message.from_base68(content)
        channel.close()
----
--

=== Ajouter un paramètre optionnel

[source,python]
----
class RadioCommunicator(Communicator):

    def __init__(self, transmitter: RadioTransmitter = None):
        self.transmitter: RadioTransmitter = transmitter
        if self.transmitter is None:
            self.transmitter = XBandTransmitter()
        ..
----

=== Tester

[source,python]
----
# Create Fake Channel
class FakeChannel(Channel):
    def __init__(self):
        self.read_buffer = []
        self.write_buffer = []
        self.is_closed = False

    def write(self, content: str): 
        self.write_buffer.append(content)

    def read(self) -> str :
        return self.read_buffer.pop()

    def close(self):
        self.closed = True

class FakeTransmitter(RadioTransmitter):
    def __init__(self, fake_channel: FakeChannel):
        self.fake_channel = fake_channel

    def get_channel(self) -> Channel:
        return self.fake_channel    
----

[source,python]
----
def test_send_message():
    # Given
    fake_channel = FakeChannel()  
    fake_transmitter = FakeTransmitter(fake_channel)
    message = Message(id=123, content=f'CONTACT server=nowhere.com')


    # When
    communicator = RadioCommunicator(transmitter=fake_transmitter)
    communicator.send(message)


    # Then
    assert len(fake_channel.write_buffer) > 0

----

=== Cas de la dépendance globale


[source,python]
----
class ReportStream:

    def __init__(self, out: IO[str])
        self.out = out

    def report_last_messages(self):
        messages = MessagesCollector.get_messages()
        if not messages:
            return
        for message in messages:
            out.write(f'ID:{message.id} => {message.content}')
----

Cette classe est dépendante d'une variable globale `MessagesCollector`.
Il est très difficile de la tester ainsi, c'est possible, mais cela doit être laborieux.

=== Singleton is an anti-pattern

Le Singleton est un pattern que l'on trouve dans le Gang OfFour pour assurer qu'il n'a a qu'une seule instance qui puisse exister.
Mais il pose d'énormes problèmes.

La classe `ReportStream` est très fortement couplée à `MessagesCollector`.
Elle n'a besoin que d'obtenir des évènements.

Typiquement une injection d'une abstraction dont la responsabilité serait de fournir des évènements seraient largement suffisant.

[source,python]
----
class MessageProvider(Protocol):

    def get_messages(self) -> list[Message]:
        ...
----



=== Travail sur le Singleton

Si on peut modifier `MessagesCollector`

* Lui faire endosser l'interface `MessageProvider`
* Lui faire returner via un `get` lui même
* Transformer la méthode de classe en méthode d'instance

[source,python]
----
class MessagesCollector(MessageProvider):

    instance = MessagesCollector()

    @classmethod
    def get(cls, self):
        return cls.instance

    @classmethod
    def set(cls, provider: MessageProvider):
        cls.instance = provider

    def get_messages(cls):
        ...
----

[source,python]
----
class ReportStream:

    def __init__(self, out: IO[str])
        self.out = out

    def report_last_messages(self):
        messages = MessagesCollector.get().get_messages()
        if not messages:
            return
        for message in messages:
            out.write(f'ID:{message.id} => {message.content}')
----

=== Test en modifiant le Singleton

[source,python]
----
@pytest.fixture
def message_provider():
    class FakeMessageProvider(MessageProvider):
        def __init__(self):
            self.messages = []

        def get_messages(self) -> list[Message]:
            return self.messages

    # Set Up
    fake_provider = FakeMessageProvider()
    instance = MessagesCollector.get()
    MessagesCollector.set(fake_provider)

    yield fake_provider

    # Tear Down
    MessagesCollector.set(instance)

----

[source,python]
----
def test_print_messages(message_provider):
    # Given
    fake_provider = message_provider
    out = io.StringIO
    report = ReportStream(out)

    fake_provider.messages = [Message(id=1, content='foo')]


    # When
    report.report_last_messages()


    # Then
    assert io.get_value() == 'ID:1 => foo'
----


=== En injectant le fournisseur

[.left-column]
--
[source,python]
----
class ReportStream:

    def __init__(self, out: IO[str])
        self.out = out

    def report_last_messages(self):
        messages = MessagesCollector.get_messages()
        if not messages:
            return
        for message in messages:
            out.write(f'ID:{message.id} => {message.content}')
----
--

[.right-column]
--
[source,python]
----
class ReportStream:

    def __init__(self, out: IO[str], provider: MessageProvider)
        self.out = out
        self.provider = provider

    def report_last_messages(self):
        messages = self.provider.get_messages()
        if not messages:
            return
        for message in messages:
            out.write(f'ID:{message.id} => {message.content}')
----
--

=== Simplification du test

[source,python]
----
class FakeMessageProvider(MessageProvider):
    def __init__(self):
        self.messages = []

    def get_messages(self) -> list[Message]:
        return self.messages

def test_print_messages():
    # Given
    fake_provider = FakeMessageProvider()
    out = io.StringIO
    report = ReportStream(out=out, provider=fake_provider)

    fake_provider.messages = [Message(id=1, content='foo')]


    # When
    report.report_last_messages()


    # Then
    assert io.get_value() == 'ID:1 => foo'
----

== Résumé

image::images/report_stream-0.svg[]

image::images/report_stream-1.svg[]

image::images/report_stream-2.svg[]

== Amélioration de la testabilité par la hiérarchisation

include::_test_by_overloading.adoc[{include_options}]


=== Simuler une base de données

* Utiliser le pattern du repository
** Insérer une couche d'abstraction si la construction des requêtes n'est pas de la responsabilité de l'objet sous test

TBD

== Boucles imbriquées 

TBD

== Recherche de responsabilité sur legacy 

TBD 

== Méthode MIKADO 

TBD


[.end.background]
[.center]
== Améliorer la testabilité

// end::content[]
