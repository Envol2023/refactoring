= Testabilité
include::../../_inc_context.adoc[]
ifndef::imagesdir[]
:imagesdir: ../../
endif::[]

// tag::content[]

== TODO

* testability and responsibility 
* testability and abstraction 

[.start.background]
[.center]
== Améliorer la testabilité




=== L'immobilisation par la peur

* La peur de tout casser.
** => Premier frein au changement

image::images/break_everything.gif[]

Aucune évolution n'est possible, à un rythme _soutenable_ sans confiance.

=== Le complexe de Frankenstein

Nous sommes tellement heureux d'avoir un code qui fonctionne assemblant des lignes de code sans cohérence

image::images/frankenstein_0.gif[alt]


=== Le complexe de Frankenstein

\... que nous ne voyons que trop tard que le code nous échappe totalement

image::images/frankenstein_1.gif[alt]

Un manque de culture conceptuel qui devient cruel et démotivant. 

== La pierre philosophale

[quote, Kent Beck]
____
Tests are the Programmer's stone, transmuting fear into boredom.
____

=== Definition de la Testabilité

[quote]
____
La testabilité d'un module est la facilité à créer une série de tests automatisés.
____

* Qualité Logicielle
** Une des caractéristiques de la _Maintenabilité_

== L'échec comme premier pas.

Dans la philosophe des tests, l'échec n'est pas négatif, c'est sa persistence qu'il l'est éventuellement.

L'échec indique qu'un état souhaité n'est pas atteint. L'objectif est de l'atteindre

=== Cycle de vie > Développement Normal


[.center]
image::images/pytest-lifecycle.png[]

=== Cycle de vie > Bug fix

[.center]
image::images/pytest-bugfix-lifecycle.png[]

=== Le TDD et refactoring

* _Test Driven Development_
** Approche érigée en philosophie


[quote,Kent Beck]
____
"Code that isn't tested doesn't work - this seems to be the safe assumption."
____

ifdef::mode_slide[=== Le TDD et refactoring]

[.center]
image::images/pytest-tdd-lifecycle.png[]

=== Testabilité, conception et confiance

[.left-column]
[.center]
--
Cercle vertueux

image::images/testability-cercle-vertueux.svg[]

--

[%step]
[.right-column]
[.center]
--
Cercle vicieux

image::images/testability-cercle-vicieux.svg[]
--

[%step]
[.reset-column.center]
--
[quote]
____
"Réalisez les projets avec des personnes motivées. Fournissez-leur l'environnement et le soutien dont elles ont besoin et _faites-leur confiance_ pour atteindre les objectifs fixés."
____
--

[NOTE.notes]
--
Il y a une relation très claire entre la conception, la testabilité et la confiance que nous plaçons dans le code.
Cette confiance agit directement sur notre motivation, notre engagement sur le projet lui-même.

La motivation est un principe très fort dans l'agilité. L'un de ces principes n'est-il pas ?

____
Réalisez les projets avec des personnes motivées. Fournissez-leur l'environnement et le soutien dont elles ont besoin et _faites-leur confiance_ pour atteindre les objectifs fixés.
____
--

=== Les tests comme bac à sable 



* Tester pour mieux cerner
** Contexte fonctionnel pour prototyper
** Jouer avec un algorithme sans lancer la grosse machinerie
* Démarche
** (1) Créer un test unitaire
** (2) Tâtonner avec un algorithme
** (3) Réussir à passer le test 
** (4) => Refactoriser l'algorithme en _beau_ code bien _clean_
* TDD à la petite semaine
** Pythoneux: alternative au notebook _pour voir_

[NOTE.notes]
--
Les test sont un merveilleux moyen d'expérimenter des algorithmes sans avoir à lancer des processus ou des traitements très lourds.
Il arrive, quand on développe des pipelines de traitements de donnée, d'avoir à relancer de lourds traitement pour tester des algorithmes.
Le fait de mettre en place des tests, même grossièrement, oblige à penser plus petit, plus réduit, plus concentré.
Une fois le cadre en place, il devient plaisant, dans un cadre simple, répétitif, sans risque de bidouiller un peu pour voir comment prendre un problème en main.
--

ifdef::mode_slide[]
[.at-top-right]
--
[.right]
image::images/stitch.gif[]
--
endif::[]

=== La testabilité et qualité de conception
____
"if an airplane looks good, it will fly good."
____

[.center]
image::images/15_Supermarine_Spitfire_R6923,_QJ-S_(15836050395).jpg[]

____
Si un code se teste facilement, il ne peut pas être entièrement mauvais...
____


[NOTE.notes]
--
Ce n'est pas une réalité statistique, mais c'est motivant.
--

=== La testabilité et qualité de conception

* Testabilité = indicateur de qualité de conception
** Un code difficile à tester -> Faiblesses de conception
** => Revoir la conception 
* La réciproque est-elle vraie ?
** Débat...


== Test facile

[.big]
[source,python]
-----
def filter_info_log(logs: List[Log]) -> List[Log]:
    return [log for log in logs if log.level == "INFO"]
-----

[.left-column]
--

[.big]
[source,python]
-----
def test_filter_info_log_empty():
    # Given
    logs = []

    # When
    result = filter_info_log(logs)

    # Then
    assert result == []
-----
--


[.right-column]
--
[.big]
[source,python]
-----
def test_filter_info_log_no_info_logs():
    # Given
    logs = [Log(level="ERROR")]

    # When
    result = filter_info_log(logs)

    # Then
    assert result == []
-----
--

=== Test moins facile

TODO Faire un accès statique 

[.big]
[source,python,attributes]
-----
class LogFilter:
    def __init__(self, rules: Rules):
        self.rules = rules
    
    def filter_info_log(self, logs: List[Log]) -> List[Log]:
        return [log for log in logs if self.rules.validate(log, "INFOS")]
-----

[.left-column]
--
[.big]
[source,python]
-----
def test_filter_info_log_empty():
    # Given
    logs = []
    rules = Rules()
    log_filter = LogFilter(rules)

    # When
    result = log_filter.filter_info_log(logs)

    # Then
    assert result == []
-----
--


[.right-column]
--
[.big]
[source,python]
-----
def test_filter_info_log_no_info_logs():
    # Given
    logs = [Log(level="ERROR")]
    rules = Rules()
    log_filter = LogFilter(rules)

    # When
    result = log_filter.filter_info_log(logs)

    # Then
    assert result == []
-----
--



=== Test franchement pas facile

[.big]
[source,python,attributes]
-----
class LogFilter:
    def __init__(self, rules: Rules):
        self.rules = rules
    ...

class Rules:
    def __init__(self, db_name: str, db_host: str, db_login: str, db_password: str):
        self. conn = psycopg2.connect(database = db_name, 
                                        user = db_login, 
                                        host= db_host,
                                        password = db_password)

        self.load_rules(self.conn)
-----

[.left-column]
--
[.big]
[source,python]
-----
def test_filter_info_log_empty():
    # Given
    conn = psycopg2.connect(database = TEST_DATABASE, 
                            user = TEST_USER, 
                            host= TEST_HOST,
                            password = TEST_PASSWORD,
                            port = 5432)
    clear_then_load_rules_in_database(conn)

    logs = []
    rules = Rules(conn)
    log_filter = LogFilter(rules)

    # When
    result = log_filter.filter_info_log(logs)

    # Then
    assert result == []
-----
--


[.right-column]
--
[.big]
[source,python]
-----
def test_filter_info_log_no_info_logs():
    # Given
    conn = psycopg2.connect(database = TEST_DATABASE, 
                            user = TEST_USER, 
                            host= TEST_HOST,
                            password = TEST_PASSWORD,
                            port = 5432)
    clear_then_load_rules_in_database(conn)

    logs = [Log(level="ERROR")]
    rules = Rules(conn)
    log_filter = LogFilter(rules)

    # When
    result = log_filter.filter_info_log(logs)

    # Then
    assert result == []
-----
--

=== Facilité et couplage

[.left-column]
--
[%step]
* Coupable couplage
** Mise en condition => beaucoup de travail
*** => instanciation de nombreux objets
* Objectifs
** => Découpler au maximum
*** Conception _propre_
** => Se libérer des dépendances
*** Plusieurs stratégies
--

[.right-column]
--
[%step]
* Action préventives 
** => Nouveau code  -> nouveau test
* Action correctives
** => Legacy code
--



=== Mocking
[.left-column-2-3]
--

* Situation complexe => Mocking
** Mock => objet simulé qui **imite** le comportement d'objets réels de manière _contrôlée_.
** Outil très puissants et utiles


* Outil pas toujours simples
** _Quand même mocker devient compliqué_ => Sérieux problème de conception.

* Effet Harry Potter
** Trop facile de se sortir d'une mauvaise situation par mauvaise conception.
* Pour plus de détails
** voir Mockito pour java https://site.mockito.org/
** voir : https://github.com/Euclid-Python/Python-pytest/blob/master/pytest-mock.ipynb

--
[.right-column-1-3]
--
[.right]
image::https://media.giphy.com/media/C3YUQjB5agrdK/giphy.gif[]


== Legacy et théorie

[quote,Michael C. Feathers]
____
Code without tests is bad code. It doesn't matter how well written it is; it doesn't mat-
ter how pretty or object-oriented or well-encapsulated it is. With tests, we can change
the behavior of our code quickly and verifiably. Without them, we really don't know
if our code is getting better or worse.
____

=== Le cercle infernale

[.center]
image::images/testability-cercle.svg[alt]

=== Obstacles à la testabilité (unitaire)

* Dépendances trop lourdes ou complexes
** Base de données, Web Servies extérieurs, Librairies tierces
** Arbre de dépendances trop profond
* Tests non idempotents 
** Liées au temps, gestion asynchrone, randomisation
* Absence d'observable
** Pas de changement d'état, pas de retour


[NOTE.notes]
--
* La mise en oeuvre demande des ressources considérables qui vont au delà des moyen du développeur
** Monter une base de données, un site extérieur
* Les tests ne sont pas répétables car ils dépendent de choses qui sont trop fluctuantes
** Heure, propriétés système, randomisation
* Je ne peux rien observer, aucun moyen de savoir si il s'est passée quelque chose.
--

=== Chirurgie de guerre 

* Tester coûte que coûte
** => Renoncer temporairement à un idéal de conception
** => Constater la conservation des comportements
* Tout est autorisé ou presque
** Mettre une variable témoin 
** Transgresser les principes de conception

**Ce qui compte est de savoir ce que fait réellement le code, avant de l'améliorer**

TODO Faire liste en référence à Legacy 



=== Test de caractérisation 

* Test de caractérisation
** _Test par approbation_
* Test _extérieur_ 
** Utilise l'idempotence d'un résultat conservé sous forme de fichier
https://approvaltests.com/


ifdef::mode_slide[=== Test de caractérisation]

[.center]
image::images/testability-approval.svg[]

ifdef::mode_slide[=== Test de caractérisation]

[.left-column]
--
[.big]
[source,python]
----
@dataclass
class City:
    name: str


@dataclass
class Address:
    street: str
    city: City

----
--

[.right-column]
--
[.big]
[source,python]
----
@dataclass
class Person:
    name: str
    age: int
    address: Optional[Address] = None
    knows: List[Person] = field(default_factory=list)

    def add_relation(self, relation: Person):
        self.knows.append(relation)



@dataclass
class Family:
    name: str
    members: List[Person] = field(default_factory=list)
----
--

[.reset-column]
--
[.big]
[source,python,attributes]
----
def find_related_people_in_same_cities(families: List[Family]):
    people_relations_by_cities = {}
    for family in families:
        for people in family.members:
            if people.knows:
                city_name = people.address.city.name
                relations = people_relations_by_cities.get(city_name)
                if not relations:
                    relations = []
                    people_relations_by_cities[city_name] = relations
                relations.append(people)
    return people_relations_by_cities
----
--

ifdef::mode_slide[=== Test de caractérisation]

Test avec approval

[.big]
[source,python]
----
from approvaltests.approvals import verify

def test_approval():
    # ___ GIVEN ____
    city = City(name='Sample City')

    alice = Person(name='Alice', age=25, address=Address(street='123 Street A', city=city))
    bob = Person(name='Bob', age=30, address=Address(street='456 Street B', city=city))
    family1 = Family(name='Smith', members=[alice, bob])
    charlie = Person(name='Charlie', age=28, address=Address(street='789 Street C', city=city))
    family2 = Family(name='Johnson', members=[charlie])

    alice.knows.append(charlie)

    # ___ WHEN ____
    related_people = find_related_people_in_same_cities([family1, family2])

    # ___ THEN ____
    verify(related_people)
----




ifdef::mode_slide[=== Test de caractérisation]


Lancement avec 

[.big]
[source,bash]
----
pytest --approvaltests-use-reporter='PythonNativeReporter'
----

Dans `Pycharm`

[.center]
image:images/capture_approval_1.png[]


ifdef::mode_slide[=== Test de caractérisation]

Sortie du test en échec

[source,text]
----
to approve this result:

move "/home/mdexet/approval_demo/tests/test_prettyworld.test_approval.received.txt" 
 "/home/mdexet/approval_demo/tests/test_prettyworld.test_approval.approved.txt"

...
code>       verify(related_people)
E       approvaltests.approval_exception.ApprovalException: Approval Mismatch, received != approved
E       	Approved: /home/mdexet/approval_demo/tests/test_prettyworld.test_approval.approved.txt
E       	Received: /home/mdexet/approval_demo/tests/test_prettyworld.test_approval.received.txt
----

Dans PyCharm

[.center]
image:images/capture_approval_0.png[width=500] 



ifdef::mode_slide[=== Test de caractérisation]

Contenu du fichier de référence `test_prettyworld.test_approval.approved.txt`

[.big]
[source,text]
----
{'Sample City': [Person(name='Alice', age=25, address=Address(street='123 Street A', city=City(name='Sample City')), 
  knows=[Person(name='Charlie', age=28, address=Address(street='789 Street C', city=City(name='Sample City')), knows=[])])]}
----


ifdef::mode_slide[=== Test de caractérisation]

Dès que le fichier est copié, le test est validé.
En cas de déviation, que ce passe-t-il ?

[.big]
[source,text]
----

tests\test_prettyworld.py:24: ApprovalException
-------------------------------- Captured stdout call --------------------------------- 
--- test_prettyworld.test_approval.approved.txt
+++ test_prettyworld.test_approval.received.txt
@@ -1 +1 @@
-{'Sample City': [Person(name='AliceFOO', age=25, address=Address(street='123 Street A', city=City(name='Sample City')), 
 knows=[Person(name='Charlie', age=28, address=Address(street='789 Street C', city=City(name='Sample City')), knows=[])])]}
+{'Sample City': [Person(name='Alice', age=25, address=Address(street='123 Street A', city=City(name='Sample City')), 
 knows=[Person(name='Charlie', age=28, address=Address(street='789 Street C', city=City(name='Sample City')), knows=[])])]}

----

Avec `WinMerge` sous Windows

[.center]
image::images/capture_approval_winmerge.png[alt]

ifdef::mode_slide[=== Test de caractérisation]

* Date ? 
** => Scrubber (_Laveur_) :  Remplace dates par placeholder `date${n}`

[.left-column-1-3]
--
[source,python]
-----
@dataclass
class DatedNote:
    note: str
    date : datetime

    def merge(self, o: DatedNote):
        self.note = f'{self.note}/{o.note}'
        d = max(self.date, o.date)
        self.date =d

-----
--
[.right-column-2-3]
--

[source,python]
-----
def test_with_date_scrubbers():
    # --Given--
    # Create 2 hours spaced datetime
    now = datetime.now()
    later = now + timedelta(hours=2)
    
    # Assign them to different notes
    dated_note0 = DatedNote("Foo", now)
    dated_note1 = DatedNote("Bar", later)

    # Ad hoc reporter
    def as_report(note: DatedNote):
        return f'NOTE:{note.note}, DATE={note.date.strftime("%Y%m%dT%H%M%SZ")}'

    # --When--
    dated_note1.merge(dated_note0)
    # --Then--
    verify(as_report(dated_note1),  
            options=Options().with_scrubber(
                DateScrubber.get_scrubber_for("00000000T000000Z")))
-----
--

[.reset-column]
--
[source,text]
----
NOTE:Bar/Foo, DATE=<date0>
----
--


=== Raison de la difficulté à tester

* La dépendance irritante
* L'instanciation cachée
* Le Singleton
* Les boucles imbriquées 

TODO Vérifie cohérence Raison de la difficulté à tester

--
=== Le paramètre irritant

[source,python]
----
class Validator:

    def __init__(self, conn: connection)
        """
        :param conn: psycopg2 connection
        """
        ...

    def validate(self, msg: Message):
        ...
    def load_rules(self, conn: connection):
        ...
----

=== Test lourd à faire

[source,python]
----
def test_validator_load_rules():
    # Given
    conn = psycopg2.connect(database = TEST_DATABASE, 
                            user = TEST_USER, 
                            host= TEST_HOST,
                            password = TEST_PASSWORD,
                            port = 5432)
    clear_then_load_rules_in_database(conn)

    validator = Validator(conn=conn)
    message = Message(id=123, content=f'CONTACT server=nowhere.com')


    # When
    is_valid = validator.validate(msg)


    # Then
    assert is_valid
----


== La dépendance cachée

[source,python]
----
class RadioCommunicator(Communicator):

    def __init__(self):
        self.transmitter = XBandTransmitter()

    def send(msg: Message) -> None: 
        if not self.check_compliance_with_very_complicated_rules(msg):
            return

        channel: XBandChannel = self.transmitter.get_channel()
        channel.write(Message.to_base68(msg))
        channel.close()

    def receive(self) -> Message:
        channel: XBandChannel = self.transmitter.get_channel()
        content = channel.read()
        if content :
            return Message.from_base68(content)
        channel.close()
----

Comment faire un test de `RadioCommunicator` alors que tout repose sur `XBandTransmitter` ?

== La dépendance cachée : le problème

La dépendance cachée traduit un problème de conception qui concerne l'initialisation des objet.
La dépendance cachée peut créer de sérieux problèmes de test, car nous ne savons pas forcément, en tant que concepteur du `RadioCommunicator` tout ce que cela implique.
L'autre problème concerne la connaissance, donc le coupage inhérent à cette dépendance cachée.

Le mieux est de reposer que l'abstraction plutôt que l'implémentation.

== La dépendance cachée : extraire l'interface du XBandTransmitter

Le XBandTransmitter semble manifestement se limiter à obtenir  un `Channel`
Le XBandChannel se limite lui à écrire, lire et se fermer.


Écrivons donc une interface `RadioTransmitter` et une interface `Channel`

[.left-column]
--
[source,python]
----
class Channel(Protocol):
    def write(self, content: str): 
        ...
    def read(self) -> str :
        ...
    def close(self):
        ...

class RadioTransmitter(Protocol):
    def get_channel(self) -> Channel:
        ...
----
--

[.right-column]
--
[source,python]
----
class RadioCommunicator(Communicator):

    def __init__(self):
        self.transmitter: RadioTransmitter = XBandTransmitter()

    def send(msg: Message) -> None: 
        if not self.check_compliance_with_very_complicated_rules(msg):
            return

        channel: Channel = self.transmitter.get_channel()
        channel.write(Message.to_base68(msg))
        channel.close()

    def receive(self) -> Message:
        channel: Channel = self.transmitter.get_channel()
        content = channel.read()
        if content :
            return Message.from_base68(content)
        channel.close()
----
--

=== Ajouter un paramètre optionnel

[source,python]
----
class RadioCommunicator(Communicator):

    def __init__(self, transmitter: RadioTransmitter = None):
        self.transmitter: RadioTransmitter = transmitter
        if self.transmitter is None:
            self.transmitter = XBandTransmitter()
        ..
----

=== Tester

[source,python]
----
# Create Fake Channel
class FakeChannel(Channel):
    def __init__(self):
        self.read_buffer = []
        self.write_buffer = []
        self.is_closed = False

    def write(self, content: str): 
        self.write_buffer.append(content)

    def read(self) -> str :
        return self.read_buffer.pop()

    def close(self):
        self.closed = True

class FakeTransmitter(RadioTransmitter):
    def __init__(self, fake_channel: FakeChannel):
        self.fake_channel = fake_channel

    def get_channel(self) -> Channel:
        return self.fake_channel    
----

[source,python]
----
def test_send_message():
    # Given
    fake_channel = FakeChannel()  
    fake_transmitter = FakeTransmitter(fake_channel)
    message = Message(id=123, content=f'CONTACT server=nowhere.com')


    # When
    communicator = RadioCommunicator(transmitter=fake_transmitter)
    communicator.send(message)


    # Then
    assert len(fake_channel.write_buffer) > 0

----

=== Cas de la dépendance globale


[source,python]
----
class ReportStream:

    def __init__(self, out: IO[str])
        self.out = out

    def report_last_messages(self):
        messages = MessagesCollector.get_messages()
        if not messages:
            return
        for message in messages:
            out.write(f'ID:{message.id} => {message.content}')
----

Cette classe est dépendante d'une variable globale `MessagesCollector`.
Il est très difficile de la tester ainsi, c'est possible, mais cela doit être laborieux.

=== Singleton is an anti-pattern

Le Singleton est un pattern que l'on trouve dans le Gang OfFour pour assurer qu'il n'a a qu'une seule instance qui puisse exister.
Mais il pose d'énormes problèmes.

La classe `ReportStream` est très fortement couplée à `MessagesCollector`.
Elle n'a besoin que d'obtenir des évènements.

Typiquement une injection d'une abstraction dont la responsabilité serait de fournir des évènements seraient largement suffisant.

[source,python]
----
class MessageProvider(Protocol):

    def get_messages(self) -> list[Message]:
        ...
----



=== Travail sur le Singleton

Si on peut modifier `MessagesCollector`

* Lui faire endosser l'interface `MessageProvider`
* Lui faire returner via un `get` lui même
* Transformer la méthode de classe en méthode d'instance

[source,python]
----
class MessagesCollector(MessageProvider):

    instance = MessagesCollector()

    @classmethod
    def get(cls, self):
        return cls.instance

    @classmethod
    def set(cls, provider: MessageProvider):
        cls.instance = provider

    def get_messages(cls):
        ...
----

[source,python]
----
class ReportStream:

    def __init__(self, out: IO[str])
        self.out = out

    def report_last_messages(self):
        messages = MessagesCollector.get().get_messages()
        if not messages:
            return
        for message in messages:
            out.write(f'ID:{message.id} => {message.content}')
----

=== Test en modifiant le Singleton

[source,python]
----
@pytest.fixture
def message_provider():
    class FakeMessageProvider(MessageProvider):
        def __init__(self):
            self.messages = []

        def get_messages(self) -> list[Message]:
            return self.messages

    # Set Up
    fake_provider = FakeMessageProvider()
    instance = MessagesCollector.get()
    MessagesCollector.set(fake_provider)

    yield fake_provider

    # Tear Down
    MessagesCollector.set(instance)

----

[source,python]
----
def test_print_messages(message_provider):
    # Given
    fake_provider = message_provider
    out = io.StringIO
    report = ReportStream(out)

    fake_provider.messages = [Message(id=1, content='foo')]


    # When
    report.report_last_messages()


    # Then
    assert io.get_value() == 'ID:1 => foo'
----


=== En injectant le fournisseur

[.left-column]
--
[source,python]
----
class ReportStream:

    def __init__(self, out: IO[str])
        self.out = out

    def report_last_messages(self):
        messages = MessagesCollector.get_messages()
        if not messages:
            return
        for message in messages:
            out.write(f'ID:{message.id} => {message.content}')
----
--

[.right-column]
--
[source,python]
----
class ReportStream:

    def __init__(self, out: IO[str], provider: MessageProvider)
        self.out = out
        self.provider = provider

    def report_last_messages(self):
        messages = self.provider.get_messages()
        if not messages:
            return
        for message in messages:
            out.write(f'ID:{message.id} => {message.content}')
----
--

=== Simplification du test

[source,python]
----
class FakeMessageProvider(MessageProvider):
    def __init__(self):
        self.messages = []

    def get_messages(self) -> list[Message]:
        return self.messages

def test_print_messages():
    # Given
    fake_provider = FakeMessageProvider()
    out = io.StringIO
    report = ReportStream(out=out, provider=fake_provider)

    fake_provider.messages = [Message(id=1, content='foo')]


    # When
    report.report_last_messages()


    # Then
    assert io.get_value() == 'ID:1 => foo'
----

== Résumé

image::images/report_stream-0.svg[]

image::images/report_stream-1.svg[]

image::images/report_stream-2.svg[]

== Amélioration de la testabilité par la hiérarchisation

include::_test_by_overloading.adoc[{include_options}]

=== Simuler une base de données

* Utiliser le pattern du repository
** Insérer une couche d'abstraction si la construction des requêtes n'est pas de la responsabilité de l'objet sous test

[.left-column]
--
[source,python]
-----
class Authentication:

    def get_user_by_id(self, user_id) -> AuthenticatedUser:
        # Execute SQL SELECT
        return user

    def update_user(self, user: AuthenticatedUser) -> AuthenticatedUser:
        # Execute SQL UPDATE
        return user            
    
    def delete_user(self, user_id): ...

    #...

-----
--

[.right-column]
--
[source,python,attributes]
-----
class UserRepository(Protocol):

    def get_user_by_id(self, user_id) -> AuthenticatedUser: 
        ...
    def update_user(self, user: AuthenticatedUser) -> AuthenticatedUser: 
        ...
    def delete_user(self, user_id): 
        ...

class Authentication:
    def __init__(self, user_repository: UserRepository):
        self.user_repository = user_repository

    def 
-----
--

TODO TBD repository

== Boucles imbriquées 

* Priorité Single Responsability Principle
** Boucles imbriquées avec plusieurs responsabilités mélangées

[.big]
[source,python]
-----
avg_w_lug = 0
total_p = 0

for r in flight.reservations:
    for lug in r.luggages:
        avg_w_lug += lug.weight if not lug.cabin or 0
    p = r.price
    if r.discnt:
        p = p * r.discnt
    total_p += p

avg_w_lug = avg_w_lug / len(reservations)
-----

[%step]
Ah oui, encore une version compressée...

ifdef::mode_slide[== Boucles imbriquées]

En clair

[.big]
[source,python]
-----
average_weight_luggage = 0
total_price = 0

for reservation in flight.reservations:
    for luggage in reservation.luggages:
        average_weight_luggage += luggage.weight if not luggage.in_cabin or 0

    price = reservation.price 
    if reservation.discount:
        price = price * reservation.discount
    total_price += price

average_weight_luggage = average_weight_luggage / len(reservations)
-----

* Comment tester et surtout quoi tester ?
** Responsabilités mélangées ? 
*** Lesquelles ?

ifdef::mode_slide[== Boucles imbriquées]

* Responsabilités identifiées
** _Calcul du poids total des baggages en soute_
** _Calcul du prix total du vol_

Réécriture

[.big]
[source,python]
-----
average_weight_luggage = 0
for reservation in flight.reservations:
    for luggage in reservation.luggages:
        average_weight_luggage += luggage.weight if not luggage.in_cabin or 0
average_weight_luggage = average_weight_luggage / len(reservations)

total_price = 0
for reservation in flight.reservations:
    price = reservation.price 
    if reservation.discount:
        price = price * reservation.discount
    total_price += price
-----

[source,python]
-----
def test_total_weight_with_some_cabin_bagages_and_without_discount():
    ...
def test_total_price_with_discounts_but_no_baggages():
    ...
-----

ifdef::mode_slide[== Boucles imbriquées]

Réécriture

[.big]
[source,python]
-----
def get_total_weight_of_in_hold_baggages(reservations: List[Reservation]) -> float:
    average_weight = 0
    for reservation in reservations:
        for luggage in reservation.luggages:
            average_weight += luggage.weight if not luggage.in_cabin or 0
    average_weight = average_weight / len(reservations)
    return average_weight

def get_total_price(reservations: List[Reservation]) -> float:
    total = 0
    for reservation in reservations:
        price = reservation.price 
        if reservation.discount:
            price = price * reservation.discount
        total += price
    return total
-----
[.big]
[source,python]
-----
def test_total_weight_with_some_cabin_bagages(): ...
def test_total_weight_without_bagages(): ...    
def test_total_price_with_some_discounts():  ...
def test_total_price_without_discounts(): ...
-----


== Design vs performance

* Un faux débat
** => Souvent la dégradation est minime
** => Les compilateurs sont capables d'optimiser  
*** Python...un peu https://wiki.python.org/moin/PythonSpeed/PerformanceTips
** Seul un profiling est pertinent
* Ce qui compte
** (1) Bien écrire le code.
** (2) Vérifier qu'il est correct (passe les tests)
** (3) Établir un profil en cas de lenteur seulement.
** (4) Optimiser si besoin.
** (5) Répéter à partir du point 2. 




== Recherche de responsabilité sur legacy (temporaire)

* Bad smells : 
** Classe trop grosse ( https://refactoring.guru/fr/smells/large-class[_Large Class_])




[NOTE.notes]
--
Nous avons vu que quand une classe semble lourde à tester, qu'elle semble lourde à tester, c'est souvent qu'elle porte trop de responsabilités. Elle fait trop de choses.
Plusieurs experts se marchent dessus en permanence, il est temps de la décomposer.
Ce genre de situation est une illustration de la dette technique: on a laissé la classe gonfler, en s'en servant comme pivot pour ajouter de nouvelles fonctionnalités.
La théorie de la conception aurait voulu que son design soit mûrement réfléchi, et ses responsabilités bien établies à l'avance. Mais ce n'est pas la réalité opérationnelle rencontrée.
--

=== Recherche de responsabilité sur legacy (temporaire) > Grouper par nom

* Proximité sémantique
** Chercher les noms de variable, de fonction qui sont proches
--
[source,python]
----
from dataclasses import dataclass

@dataclass
class People:
    name: str
    age: int
    gender: str
    address: str
    phone_number: str
    email: str
    company_name: str
    company_address: str
    job_title: str
    job_description: str
----

[source,python]
----
    def send_email(self, message: str) -> None: ...
    def call_by_phone(self) -> None: ...
    def change_job_title(self, new_title: str) -> None: ...
    def update_address(self, new_address: str) -> None: ...
    def get_personal_info(self) -> str: ...
    def get_company_info(self) -> str: ...
    def update_personal_info(self, name: str, age: int, gender: str, address: str, phone_number: str, email: str) -> None: ...
    def update_company_info(self, company_name: str, company_address: str, job_title: str, job_description: str) -> None: ...
    def calculate_salary(self) -> float: ...
    def hire_employee(self, employee_info: dict) -> None: ...
    def fire_employee(self, employee_id: int) -> None: ...
    # ... Other methods ...

----
--

ifdef::mode_slide[]
[%notitle]
=== Recherche de responsabilité sur legacy (temporaire) > Grouper par nom
endif::[]

Éclatons les propriétés et les noms de méthodes

[.center]
image::images/testability-srp_0.svg[]

ifdef::mode_slide[]
[%notitle]
=== Recherche de responsabilité sur legacy (temporaire) > Grouper par nom
endif::[]

Identifions des groupes de propriétés et les noms de méthodes

[.center]
image::images/testability-srp_1.svg[]

ifdef::mode_slide[]
[%notitle]
=== Recherche de responsabilité sur legacy (temporaire) > Grouper par nom
endif::[]

Identifions des groupes de propriétés et de noms de méthodes

[.center]
image::images/testability-srp_1.1.svg[]

ifdef::mode_slide[]
[%notitle]
=== Recherche de responsabilité sur legacy (temporaire) > Grouper par nom
endif::[]

Relions des groupes de propriétés et de noms de méthodes

[.center]
image::images/testability-srp_2.svg[]

ifdef::mode_slide[]
[%notitle]
=== Recherche de responsabilité sur legacy (temporaire) > Grouper par nom
endif::[]

Identifions des responsabilités

[.center]
image::images/testability-srp_3.svg[]

ifdef::mode_slide[]
[%notitle]
=== Recherche de responsabilité sur legacy (temporaire) > Grouper par nom
endif::[]

Reconsidérons la classe originelle

[.center]
image::images/testability-srp_4.svg[]

ifdef::mode_slide[]
[%notitle]
=== Recherche de responsabilité sur legacy (temporaire) > Grouper par nom
endif::[]

Nous avons dégagé plusieurs responsabilités différentes.

La classe `People` devient une composition

[.left-column]
--
[source,python]
----
from dataclasses import dataclass

@dataclass
class People:
    person: Person
    address: Address
    phone_number: PhoneNumber
    email: Email
    company: Company
    job: Job
----
--

[.right-column]
--
[.right.at-middle]
image::images/testability-srp_5.svg[]
--

[.reset-column]
Maintenant il est possible de tester chaque classe indépendamment _chacune dans son  domaine d'expertise_

=== Recherche de responsabilité sur legacy (temporaire) > Grouper par nom

Et de se limiter aux rares méthodes qui implique plusieurs classes comme

[source,python,attributes]
-----
@dataclass
class People:
    #...
    def update_personal_info(self, name: str, age: int, gender: str, address: str, phone_number: str, email: str) -> None: ...
    def update_company_info(self, company_name: str, company_address: str, job_title: str, job_description: str) -> None: ...
    def calculate_salary(self) -> float: ...
    def hire_employee(self, employee_info: dict) -> None: ...
    def fire_employee(self, employee_id: int) -> None: ...
-----

=== Recherche de responsabilité sur legacy (temporaire) > Grouper par ce qui change

* Scratch refactoring
** => Modifier pour voir ce qui se passe
** Ne pas chercher à conserver
** Découvrir les éléments qui "cassent" en même temps
* Philosophie du scratch
** _Ce qui change ensemble va ensemble_
** _Ce qui ne casse pas ensemble ne va pas ensemble_
* Attention de le faire dans une branche bidon.

[.at-middle-right]
image::images/scratch.png[]


=== Recherche de responsabilité sur legacy (temporaire) > Grouper par relations

[.left-column-2-3]
--

* Grouper par relations
** Si première approche sémantique KO
*** => les noms sont mal formés (tiens, tiens...) par exemple
** Etablir relations entre méthodes et propriétés **dans le code**
* Faire un graphique
** cf _Working Effectively with Legacy Code. p 255_

--

[.right-column-1-3]
--
[.center]
image::images/capture_Working_graph.png[height=300]
--

ifdef::mode_slide[]
[%notitle]
=== Recherche de responsabilité sur legacy (temporaire) > Grouper par relations
endif::[]

[.center]
image::images/testability-srp_interne_0.svg[]

ifdef::mode_slide[]
[%notitle]
=== Recherche de responsabilité sur legacy (temporaire) > Grouper par relations
endif::[]

[.center]
image::images/testability-srp_interne_1.svg[]

ifdef::mode_slide[]
[%notitle]
=== Recherche de responsabilité sur legacy (temporaire) > Grouper par relations
endif::[]

[.center]
image::images/testability-srp_interne_2.svg[]


== Méthode MIKADO 




[.end.background]
[.center]
== Améliorer la testabilité

// end::content[]
