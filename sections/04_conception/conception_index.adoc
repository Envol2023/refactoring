= Conception
include::../../_inc_context.adoc[]
ifndef::imagesdir[]
:imagesdir: ../
endif::[]
:toc:

// tag::content[]


[.start.background]
[.center]
== Améliorer la conception

Améliorer la conception : niveau compétence

=== Conception Logicielle

* Conception vs Architecture ?
** Limites pas toujours nettes <= cas des frameworks _invasifs_.
* Architecture : 
** Description haut niveau de la solution, 
** Éloignée des contingences du langage.
** Lien exigences fonctionnelles <--> réponses apportées.
* Conception
** Proche du code et du langage
** Définition des entités, des données et des traitements
** Utilisation des paradigmes (OOP, fonctionnel, impératifs, ...) 


[NOTE.notes]
--
Architecture logicielle vs conception logicielle.

La différence entre les deux peut être plus ou moins nette, notamment en fonction de la complexité et la taille du logiciel.

Nous retiendrons que l'architecture logicielle est une description de haut-niveau, aussi agnostique et indépendante de l'écosystème (langages, frameworks…,) que possible.
Elle fait le lien entre les exigences fonctionnelles et les réponses apportées.

La conception logicielle s'attache plus à la structuration du code, des données et des traitements, la définition des entités et l'utilisation des mécanismes du paradigme utilisé (OOP, fonctionnel, impératif…,) 

Dans certaines situations, le framework sous-jacent est tellement invasif qu'il à tendance à contraindre l'architecture logicielle.
Nous ne nous étendrons pas sur la pertinence ou non de ce mode de fonctionnement.
--

=== Refactoring de la conception

* Améliorations des aspects _internes_ uniquement
** Gestion de la *complexité*
** Réduction de la *dette technique* du passé en gardant un oeil sur l'avenir
* Conservation du comportement observable
** Aspect _Fonctionnel_ conservé
** Aspects _Sécurité_ et _Performance_ supposés conservés


[NOTE.notes]
--

Le comportement observable, c'est ce que perçoit un utilisateur du système _de l'extérieur_, ce que nous pouvons résumer grossièrement à trois aspects : les fonctionnalités offertes, la sécurité, les performances.

Dans le cadre du refactoring, nous considérons qu'aucune évolution dans ces 3 domaines n'est à considérer, même s'il est effectivement courant de faire un refactoring pour améliorer les performances ou minimiser la consommation de ressources.

Pour la sécurité dans la conception, vous pouvez voir les documents de l'ANF https://archive-devlog.cnrs.fr/anf-nmsaw2016, 
notamment https://archive-devlog.cnrs.fr/_media/nmsaw2016/anf-nmsaw-module-3.2-bonne_pratiques.pdf  et https://archive-devlog.cnrs.fr/_media/nmsaw2016/anf-nmsaw-module-3.4-principes.pdf

--  

== Gestion de la complexité

[%step]
[.left-column-2-3]
* La complexité croit avec
** le nombre d'éléments distincts à prendre en compte
** le nombre d'interactions entre éléments
* Saturation de nos capacités cognitives
** Petit buffer pour charger un contexte en entier
** Dispersion sur des sujets très différents
* Décomposer le gros problème 
** En plusieurs petits problèmes
** Reliés entre eux
** Plus faciles à isoler, à maîtriser

[%step]
[.right-column-1-3]
image::images/breakdown-problem.gif[height=50%]

include::breakdown.adoc[]

== Modularité

[.left-column-2-3]
--
[%step]
* Décomposition 
** => réduction de la complexité
* Modularisation
** Percevoir le système comme un jeu de construction 
* Module
** Entité du langage 
*** _module python, package java, classes, ..._
** identifiable 
** suffisamment autosuffisant, 
** potentiellement réutilisable.
--

[.right-column-1-3]
--
image::images/as_legos.jpg[]
--

[NOTE.notes]
--
En applicant la décomposition d'un ensemble complexe en sous-éléments moins complexes, nous faisons un premier pas vers la modularisation.
C'est à dire que nous cherchons à obtenir des sous-composants que nous pouvons manipuler, sur lesquels nous concentrer, et au besoin, remonter notre attention à un niveau au dessus pour avoir une vision plus globale.

Avoir un ensemble isolé est une condition nécessaire mais pas suffisante pour considérer un sous-composant comme un module. Dans l'idéal, il faudrait qu'il soit identifiable, suffisamment autosuffisant et potentiellement réutilisable.
--

[.splash.background]
[.center]
[%notitle]
== What is a code ?

[%step]
Que mettons nous dans un module ?
[%step]
Du code.
[%step]
[.huge]
--
Code = Données + Traitements
--

=== Code = Données + Traitements

[.center]
image::images/data_algo.png[]


=== Code = Données + Traitements

[.left-column]
--
**Données**

* _Partie passive_
** Variables, constantes, _valeurs_
** État des entités
* Différentes structurations
** Scalaires, conteneurs, structures, ...

[.big]
[source,python]
----
a = 1
name = 'John Doe'
colors = ['red', 'blue', 'green']
book = {'title': 'Python', 'pages': 324}
...
----
--

[.right-column]
[.fragment]
--
**Traitements**

* _Partie active_
** Créer ou modifier des _données_
** Se comporter
* Procédures
** Fonctions, méthodes

[.big]
[source,python]
----
# computations
b = a*a

def transform_to_french_title(input: str)
    return input[0].upper()+input[1:]

# modifications
def drop_blue(colors):
    colors.remove('blue')

...
----
--


[.center]
=== Comment relier les données et les traitements ?

--
[%step]
Une question _pas si_ évidente
[%step]
Plusieurs réponses
--

[%step]
--
Réponses => paradigmes de programmation

* *Procédural*
* *Objet*
* *Fonctionnel* 
* ...
--

=== Procédural

[.left-column-2-3]
--
* Paradigme habituel
** Le plus facile et le plus ancien

[.big]
[source,python]
----
entity = ...
procedure(entity)
----

* *Marionnettiste*
** Données inertes et passives d'un côté 
** Procédures actives de l'autre côté
--

[.right]
[.right-column-1-3]
--
image::images/puppet_master.png[]
--

=== Procédural

[.left-column-2-3]
--
* *Disjoint*
** La relation doit être établie
* *Déséquilibrée*
** Les traitements détiennent toutes les *connaissances*.
** Les structures de données sont "stupides".
--

[.right]
[.right-column-1-3]
--
image::images/puppet_master_relationship.png[]
--


=== Structuration

--
* La _forme_ des données détermine l'expressivité de la procédure
* Une meilleure structuration pour 
** => Mettre en avant ce qui est important 
** => Mettre en arrière les détails non pertinents

--

include::bob_the_rover.adoc[{include_options}]

[.splash.background]
[.center]
== Regrouper

Regrouper données et traitements, au sein d'un même module, aide à réduire la complexité.

== Comment établir un module ?

[.left-column]
--
* Critères
** Comment savoir ce qui va ensemble et ce qui est différent ?
* Interface
** Séparation entre composants
** Comment interagir avec les autres modules
--

[.right-column]
--
[.right.middle]
image::images/design-module.png[height=40%]
--

[NOTE.notes]
--
Les mathématiques ont développé la théorie des ensembles pour traiter de ce genre de question. Toutefois, aussi belle et pertinente soit-elle, ce n'est pas forcément elle qui va être la plus utile au quotidien aux développeuses et développeurs qui doivent faire face à tas de lignes de code qui sont tout simplement impossible à comprendre sans sentir le tournis.

Ce que veulent faire ces personnes, c'est trouver le moyen d'établir les critères qui permettent de savoir si un ensemble d'instructions font parties d'un ensemble ou non.

Cette question est presque d'ordre générale pour l'humain : il passe son temps, parfois à son corps défendant, à tout classer. Les événements, les éléments de la nature, les sons, les situations et aussi les autres humains, afin de pouvoir se faire l'économie d'une réflexion et d'une écoute. De même que le cerveau filtre ce qu'il veut ignorer pour éviter la saturation, comme l'herbe dans le dos quand nous sommes allongés au soleil dans un parc, mais qu'il est capable de regarder attentivement sur des araignées et des fourmis sont aperçues dans le proche voisinage.

Établir des frontières, des interfaces, des critères, c'est une technique de minimisation de l'effort cognitif.
Ca tombe bien, car c'est notre objectif aussi.
--

== Cohésion, couplage et abstraction

Pour qualifier un module, on utilise souvent trois propriétés

* La cohésion d'un module
* Le couplage entre modules
* Le niveau d'abstraction du module

=== Cohésion

[quote]
____
La cohésion indique à quel point les différentes parties d'un module sont liées entre elles et comment elles se concentrent sur la réalisation d'un objectif commun spécifique.
____

[%step]
* Faible cohésion
** Le lien entre les composants est inexistant ou futile.
* Forte cohésion
** Les composants contribuent à une seule et unique tâche bien spécifique.

=== Couplage

[quote]
____
Le couplage indique à quel point des modules différents sont interdépendants.
____

// [.at-top-right]
// image::images/coupling.gif[height=300px]

[%step]
* Faible couplage
** Les composants des différents modules n'échangent pas d'information.
* Fort couplage
** les composants des différents modules lisent et modifient directement leurs données respectives.

=== Abstraction

[quote]
____
L'abstraction est la représentation des caractéristiques essentielles d'une entité sans se préoccuper de sa forme concrète.
____

include::_cohesion_coupling_combinaisons.adoc[]

include::_cohesion_coupling_types.adoc[]

include::_typing.adoc[]

== Définition d'un bon module

*A déplacer plus bas*

[%step]
* Caractérisation d'un bon module
*** Forte cohésion
*** Faible couplage
*** Niveau d'abstraction adapté
* Objectifs du refactoring
** Transformer le code de façon à avoir de _bons_ modules

=== Couplage et cohésion

[%step]
* Couplage et Cohésion sont sur un bateau...
* Notions liées
** Cohésion -> vision intra-module
** Couplage -> vision inter-modules
* Notions résiduelles
** Couplage _résiduel_ => coopération nécessaire pour atteindre des objectifs de haut-niveau
** Cohésion parfaite => pas facile à conserver lors des évolutions
* Pas évidentes à mesurer
** Existence de métriques mais très théorique et peu utilisables
* Comment pouvons nous **améliorer les choses** ?
** Maintenant que nous savons ?

[NOTE.notes]
--
Il existe des métriques, mais elles ne sont pas évidentes à utiliser au quotidien.



REP (Reuse/Release Equivalence Principle)
"the granule of reuse is the granule of release"

CCP (Common Closure Principle)
"Gather into components those classes that change for the same reasons and at the same times. Separate into different components those classes that change at different times and for different reason"

A component (class, method, …) should not have multiple reasons to change

CRP (Common Reuse Principle)
"Don’t force users of a component to depend on things they don’t need."
--

[.splash.background]
[.center]
[%notitle]
=== Couplage et cohésion

Couplage et cohésion traduisent le niveau de connaissances nécessaires 

L'objectif de la refactorisation est de minimiser ces connaissances.

=== Couplage et cohésion > subdivision du travail

[.left-column-2-3]
--
* Analogie pour orienter le refactoring
** Système complexe faisant appel à plusieurs domaines d'expertise
** Des expert(e)s
--
[.right-column-1-3]
--
image:images/design-system-expert_0.svg[]
image:images/design-system-expert_2.svg[]
--

=== Couplage et cohésion > subdivision du travail

[.left-column-2-3]
--
* Décomposition 
** du système  -> en sous-systèmes _moins complexes_ 
** du travail -> tâche par domaine d'expertise
--
[.right-column-1-3]
--
image:images/design-system-expert_1.svg[]
image:images/design-system-expert_3.svg[]
--

=== Couplage et cohésion > subdivision du travail

[.left-column-2-3]
--
* Pourquoi ?
** Pour les confier à **ceux qui savent** 
** -> Un module <==> un(e) expert(e)
* Expert(e)
** Connaît très bien son domaine, sa culture, ses règles 
*** => *Forte Cohésion*
** Ne devrait en savoir plus que nécessaire sur les autres domaines 
*** => *Faible Couplage*
* Démarche d'optimisation
** Maximiser la compétence, 
** Minimiser les risques de mauvaise compréhension
** Minimiser les modifications en cascade

--

[.right-column-1-3]
--
image:images/design-system-expert_4.svg[]
--


[NOTE.notes]
--
Imaginer que vous avez le logiciel de vol d'un instrument spatial embarqué sur un satellite dans le cadre d'une mission de l'ESA.
Le logiciel de vol est composé 

* d'un système de communication avec le logiciel de bord du satellite, 
* d'un module de la mémoire de bord, 
* d'un module de dialogue et pilotage avec le système optique, 
* d'un module de dialogue avec les sondes de températures, 
* d'un module de dialogue avec les systèmes de calibration, les systèmes mécaniques etc...

On perçoit aisément que les domaines d'expertises sont très variés, et que la bonne attitude est de confier les modules à ceux qui savent.

C'est la subdivision du travail en fonction de l'expertise nécessaire. Vous n'allez pas confier le module de pilotage du système optique au service thermique !

Pourquoi ?

Parce que vous faites l'hypothèse raisonnable que les experts font mieux ce pour quoi ils sont experts que lorsqu'ils vont s'aventurer dans un domaine en dehors de leur expertise.
Car ainsi, ils se focalisent sur ce qu'ils savent très bien faire et minimisent les connaissances nécessaires.
--

=== Couplage et cohésion > gestion de la connaissance

[.left-column]
--
* Cohésion
** Vision *intra*-module
** *Minimisation* de la connaissance nécessaire
*** *Concentration* sur un domaine d'expertise, 
*** À l'*intérieur* de ses frontières

[.center]
image::images/design-cohesion_vs_coupling_0.png[height=300]
--

[.right-column]
--
* Couplage
** Vision *inter*-modules
** *Augmentation* de la connaissance nécessaire
*** *Dispersion* au delà du domaine d'expertise, 
*** À l'*extérieur* des frontières

[.center]
image::images/design-cohesion_vs_coupling_1.png[height=300]
--

[NOTE.notes]
--
La cohésion correspond à la minimisation des connaissances nécessaires à la compréhension d'un module. C'est une vision interne au module.

* Un module à forte cohésion pourrait être placé sous la responsabilité d'un expert dont le savoir est concentré sur un domaine précis à une échelle donnée.

Par exemple au sein d'un logiciel de vol tel que décrit précédemment, le module pilotage de l'électronique principale sera plutôt confié à un ou une spécialiste de l'électronique de l'instrument.
Au sein de ce module pilotage

* la partie compression de données peut être confié à un expert compression
* la partie gestion de la puissance confié à un expert électronique de puissance
* etc...

Le couplage correspond à l'augmentation de la connaissance nécessaire de plusieurs domaines d'expertise.
Du point de vue d'un concepteur de module, le couplage implique une connaissance plus ou moins poussée de modules autre que le sien.

Pour reprendre notre exemple, un fort couplage serait que le concepteur la partie compression sache comment le module optique fonctionne intimement.
--

[.splash.background]
[%notitle]
[.center]
=== Couplage et cohésion

[%step]
Définissez vos modules comme si vous aviez une armée d'expert(e)s à votre disposition.
[%step]
Chaque module est associé à un expert, réel ou dans votre tête, et un seul.
[%step]
La compréhension et la conception d'un module ne nécessite qu'une casquette d'expert.


== Nature de l'interface

[.left-column-2-3]
--
* L'interface
** Sépare les modules
** Permet les interactions modules
* Plusieurs types d'interfaces
** Espaces de nommage => packaging, modules python 
** Interface => au sens moyen d'interagir
* Objectif conception 
** *Minimiser* les impacts des _modifications_ en cas d'évolution des structures internes
** Produire des modules à forte cohésion et faible couplage
--
[.right-column-1-3]
[.center]
image::images/design-cohesion_vs_coupling_2.png[height=300]

[NOTE.notes]
--
L'interface sert de frontière entre les modules. Ces frontières sont de plusieurs nature.
Par exemple l'espace de nommage dans lequel les entités sont organisé définit une frontière et suivant les écosystèmes des intimités différentes.

Par exemple, _java_ prévoit un niveau de visibilité, _protected_ qui permet une visibilité par tous les membres du même _package_.

Python peut, en jouant sur les initialisations de packages au sein des `__init__.py`, offrir une visibilité _choisie_ en fonction de ce que le concepteur veut montrer, mais cela reste encore très libéral. Python est un langage de gentlemen, et un gentlemen est censé se garder de regarder là où il ne doit pas.

--

[.splash.background]
[.center]
[%notitle]
=== Nature de l'interface

Comment améliorer les interfaces pour répondre à ces exigences ?


[%step]
**Minimiser la connaissance requise**


[%step]
**Rendre l'interface la plus abstraite possible**

=== Abstraction

* Description *minimale* d'un module
** Interactions, services fondamentaux
* Utilisateur du module
** Minimisation des connaissances => _Que dois-je savoir au minimum pour utiliser ce module ?_
* Concepteur du module
** Minimisation de l'exposition => _Que dois-je montrer au minimum pour être utiliser ?_

=== Exemple d'interface 

Module de communication 

Communicator
Send 
Receive 
Message 

Mettre ici schéma découplage 

=== Abstraction et contractualisation 

* Compréhension
** L'abstraction est plus facile à manipuler, définir, échanger
* Élément de communication 
** Entre utilisateurs et concepteurs
* Contractualisation 
** Engagement des concepteurs envers ses utilisateurs
** Formalisation des exigences minimales des utilisateur envers des concepteurs
* Liberté d'action pour le concepteur
** Tant que l'interface (contrat) est respectée, tout est possible



=== Illustration des bénéfices de l'abstraction

[.center]
image::images/M2_OSAE-interface.svg[]

* 3 modules différents

ifdef::mode_slide[]
[transition=none]
[%notitle]
=== Schéma Interface
endif::mode_slide[]

[.center]
image::images/M2_OSAE-interface_0-1_.svg[]

* 3 modules différents
** Avec des structures internes.

ifdef::mode_slide[]
[transition=none]
[%notitle]
=== Schéma Interface
endif::mode_slide[]

[.center]
image::images/M2_OSAE-interface_0-2_.svg[]

* 3 modules différents
** Avec des structures internes *et des interfaces.*

ifdef::mode_slide[]
[transition=none]
[%notitle]
=== Schéma Interface
endif::mode_slide[]

[.center]
image::images/M2_OSAE-interface_1_.svg[]

* Communication
** un composant _interne_ doit interagir avec le module du milieu

ifdef::mode_slide[]
[transition=none]
[%notitle]
=== Schéma Interface
endif::mode_slide[]

[.center]
image::images/M2_OSAE-interface_2_.svg[]

* Communication
** un composant _interne_ doit interagir avec le module du milieu

ifdef::mode_slide[]
[transition=none]
[%notitle]
=== Schéma Interface
endif::mode_slide[]

[.center]
image::images/M2_OSAE-interface_3_.svg[]

* Communication
** Cette interaction modifie son état interne.

ifdef::mode_slide[]
[transition=none]
[%notitle]
=== Schéma Interface
endif::mode_slide[]

[.center]
image::images/M2_OSAE-interface_4_.svg[]

* Communication
** Il veut communiquer son état à celui de gauche

ifdef::mode_slide[]
[transition=none]
[%notitle]
=== Schéma Interface
endif::mode_slide[]

[.center]
image::images/M2_OSAE-interface_5_.svg[]

* Communication
** Il veut communiquer son état à celui de gauche

ifdef::mode_slide[]
[transition=none]
[%notitle]
=== Schéma Interface
endif::mode_slide[]

[.center]
image::images/M2_OSAE-interface_6_.svg[]

* Communication
** Ce message modifie son état interne.

ifdef::mode_slide[]
[transition=none]
[%notitle]
=== Schéma Interface
endif::mode_slide[]

--
* De l'extérieur _(utilisateur)_,
** seules les interfaces sont perceptibles

[.center]
image::images/M2_OSAE-interface_7_.svg[]
--

[%step]
--
* De l'intérieur _(concepteur)_,
** seules les interfaces sont à prendre en compte

[.center]
image::images/M2_OSAE-interface_8_.svg[]
--


=== Abstraction de l'interface

[%step]
* Avantages
** Fournit *stabilité* et *simplicité* de manipulation
** Permet de communiquer et contractualiser entre groupe de personnes
** Est concentrée sur la représentation (modélisation) 
** Cache les détails d'implémentation
* Inconvénients
** Un peu _overkill_ dans des cas très simples
** Ne permet pas de faire "tourner" le code


== Cohésion, Cohérence et Abstraction

[.left-column-2-3]
--
* Orientation du refactoring
** Renforcer la cohésion du module
** Diminuer le couplage entre modules
** Accroître l'abstraction de l'interface
* Refactoring => Minimisation 
** De la **connaissance** 
*** Pour la compréhension, donc la conception
** Des efforts pour faire **évoluer** la conception
--

[%step]
[.right-column-1-3]
--
* => Éviter 
** les effets de bords 
** et réactions en chaîne
[.center]

image::images/reaction_en_chaine.gif[]
--

== Technique de refactoring pour améliorer la conception

* `Extract Method`
* `Move Method`
* `Move Field`
* `Extract Class`


[.subsection.background]
[.center]
== Principes de conceptions fondamentaux

=== Principes de conceptions fondamentaux

* Les principes à connaître absolument sont 
** Separation of Concern
** Single Responsibility Principle

=== Separation of concern

* Séparer les composants par type de préoccupation
** C'est bon, je pense qu'on a tous compris...
** Identifier, séparer, déplacer, regrouper...

=== Single Responsibility Principle

_You have one job, only one job_

[%step]
* Ce principe s'applique aussi bien 
** aux fonctions 
** qu'aux classes

== Responsabilité

[quote]
____
Une **responsabilité** est un ensemble de données et de traitements, {cr} 
que l'on peut identifier et associer {cr}
à un *domaine d'expertise* clairement identifié {cr}
et à lui seul.
____

[%step]
* Analogie des experts 
** Domaine d'expertise => limité, cohérent, concentré
* Exemples
** _Affichage du site selon la charte graphique_ => Expertise _Création graphique_
** _Calcul des totaux des consommations d'énergie_ => Expertise _Suivie énergétique_
* Contre exemple
** _Vente de poissons et de fleurs_ => Poissonnier ? Fleuriste ?


[NOTE.notes]
--
Une responsabilité est un ensemble de données et de traitements que l'on pourrait identifier et associer à un domaine d'expertise et à lui seul.

C'est une notion très subjective, car elle dépend de l'échelle de détails jusqu'où on veut aller.

Mais l'idée est que tout ce qui concerne ce domaine d'expertise est dans cette ensemble délimité, dans ce module, et que par conséquent, toutes les modifications demandées dans le cadre de ce domaine ne concerne que cet ensemble.
--

=== Single Responsibility Principle: fonctions

**Règle d'Or**

[quote,Uncle Bob,Code Clean]
____
Une fonction ne doit faire **qu'une** chose, une **seule** chose, mais bien.
____

=== Illustration 

[.left-column]
--
[source,python]
----
def end_process(process: Process, ctx: Context):
    process.end() <1>

    file = ctx.get_file() <2>
    if file: 
        with open(file,'w') as f:
            ... # Do something with file
    user = ctx.get_user() <3>
    if user: 
        ... # Do something with user
----
[.smaller]
<1> Gestion d'un process
<2> Récupération et gestion d'un fichier
<3> Récupération et gestion d'un utilisateur
--

[.right-column]
--
[.smaller]
* Constat
** Gestion d'un process d'un côté
** Gestion d'un fichier et d'un utilisateur de l'autre
--
=== Illustration 

[.left-column]
--
[source,python]
----
def end_process(process: Process, ctx: Context):
    process.end()

    save_file_alert_user(ctx) <1>

def save_file_alert_user(ctx: Context): <2>
    file = ctx.get_file()
    user = ctx.get_user()
    if file:
        with open(file,'w') as f:
            ... # Do something with file
    if user:
        ... # Do something with user

----
[.smaller]
<1> Séparation des préoccupations
<2> Création d'une fonction `save_file_alert_user`
--

[.right-column]
--
* Mais `save_file_alert_user` ...
** n'est pas réutilisable en dehors de ce cas d'usage
** fait deux choses très différentes
** => 2 domaines d'expertise impliqués
*** _Spécialiste de la sauvegarde des fichiers_ 
***  _Spécialiste des communications avec l'utilisateur_
--
=== Illustration 

[source,python]
----
def end_process(process: Process, ctx: Context):
    process.end()
    save_file(ctx.get_file()) <1>
    alert_user(ctx.get_user()) <2>

def save_file(file): <1>
    if file:
        with open(file,'w') as f:
            ... # Do something with file
def alert_user(user): <2>
    if user:
        ... # Do something with user
----
[.smaller]
<1> `save_file` relève du domaine d'expertise _Spécialiste de la sauvegarde des fichiers_  et lui seul
<2> `alert_user` relève du domaine d'expertise _Spécialiste des communications avec l'utilisateur_ et lui seul

=== Illustration 

[source,python]
----
def end_process(process: Process, ctx: Context):
    process.end()
    do_post_process(ctx) <1>

def do_post_process(ctx: Context): <2>
    save_file(ctx.get_file())
    alert_user(ctx.get_user())

def save_file(file): <3>
    if file:
        with open(file,'w') as f:
            ... # Do something with file
def alert_user(user): <4>
    if user:
        ... # Do something with user
----
[.smaller]
<1> Introduction de `do_post_process`
<2> `do_post_process` cache des détails sans importance du point de vue du _Spécialiste de la gestion des processus_ mais est *adaptable* suivant les situations.
<3> `save_file` fait une seule chose, mais bien
<4> `alert_user` fait une seule chose, mais bien


=== Single Responsibility Principe : application à une classe

[Quote]
____
Une classe ne doit changer que pour une seule raison
____

[%step]
_Formulée ainsi, cette définition semble énigmatique, sauf si ..._

=== Single Responsibility Principe : application à une classe

* Si nous la relisons selon la règle d'or : 

[Quote]
____
Comme une classe ne doit prendre en charge qu'une seule responsabilité, et bien le faire, {cr}
seule une évolution de cette responsabilité peut motiver la modification de la classe.
____

* Une raison 
** => Une évolution de la responsabilité
** => Un changement de règle au sein du domaine d'expertise

=== Illustration

Exemple un capteur barométrique joignable par adressage IP

[.big]
[source,python]
----

class BarometricSensor:

    def __init__(self):...

    def get_pressure(self) -> float:...
    
    def set_ip_address(self, ip: str):...

    def connect_to_ip_address(self) -> bool:...

----
 
=== Illustration

* Deux responsabilités distinctes
** La gestion du capteur => _Expertise mesure des pressions_
** La gestion de l'adressage IP => _Expertise réseau_


[.big]
[source,python]
----
class BarometricSensor:

    def __init__(self):...

    def get_pressure(self) -> float:...<1>
    
    def set_ip_address(self, ip: str):...<2>

    def connect_to_ip_address(self) -> bool:...<2>

----
[.smaller]
<1> _Expertise mesure des pressions_
<2> _Expertise réseau_


=== Illustration

* Application du _Single Responsibility Principle_
** Une classe porte la responsabilité _Gestion de l'adresse IP_
+
[.big]
[source,python]
----
class IpAddress:
    def __init__(self, address: str): ...
    def check(self): ...
----
+
** Une classe porte la responsabilité _Gestion mesure des pressions_
+
[.big]
[source,python]
----
class BarometricSensor:

    def __init__(self):
        self.address : IpAddress = None

    def get_pressure(self) -> float:...
    
    def set_ip_address(self, ip: str):
        self.address = IpAddress(ip) <1>

    def connect_to_ip_address(self) -> bool:
        return self.address.check() <1>
----
[.smaller]
<1> _Délégation_, au sein de `BarometricSensor` à `IpAddress`

=== Application SRP 

Si l'adressage ip passe de IPV4 à ipv6, stylée la classe réseau change. 

Si le modèle physique de mesurée barometric change, seule la classe capteur change. 

== Segregation of interface 

En montrer le moins possible 



[.end.background]
[.center]
== Améliorer la conception : conclusion

Améliorer la conception : niveau compétence


// end::content[]
