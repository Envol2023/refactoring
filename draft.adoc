= Refactoring, Optimisation and Agility
ifdef::backend-revealjs[]
include::_inc_revealjs.adoc[]
endif::[]
ifndef::backend-revealjs[]
:toc: left
:toc-title: Table des matières
:toclevels: 4
:doctype: book
endif::[]
include::_inc_context.adoc[]
:print-detail: true
:print-timing: true
:ROLE: notes
:include_options: tag=content

== Introduction



[NOTE.note]
--
Les développeurs et développeuses, que ce soit dans un contexte d'agilité ou pas, pratiquent le refactoring.

Pourtant, c'est un sujet rarement abordé en tant que soi, alors que c'est un domaine très riche. 
Alors qu'il peut paraître très technique, ce thème me semble une opportunité de prendre un peu de recul sur notre métier et le contexte propre au milieu de l'Enseignement Supérieur et de la Recherche.

Ce que je vais dire est une réflexion personnelle basée sur mon expérience, en tant qu'ingénieur, mais aussi membre de jury et surtout ancien animateur du réseau DevLOG.

Nous avons, dans le domaine du développement logiciel, des répartitions de profils qui ne se retrouvent pas ailleurs.

Les personnes en charge du développement logiciel ne proviennent pas ou peu, de mon expérience, de formation orientées développement logiciel. 
Les rares candidatures que nous avons reçus sont généralement découragées par nos niveaux de salaire et nous le constatons à travers des difficultés de recrutement qui sont de plus en plus criantes. 
Les salaires offerts ne sont pas attrayants, surtout sur le marché du développement, ce qui induit une représentation différente de ce que l'on peut trouver dans les entreprises par exemple.

Nous rencontrons des personnes qui veulent donner un sens à leur activité (c'est mon cas), mais aussi des personnes qui viennent d'abord par intérêt pour le domaine, puis pour le métier.

Globalement nous avons plus de personnes qui vont vers le développement que de personnes qui en viennent
Nous avons donc des gens qui ont des backgrounds et des cultures très diverses: certains ont un parcours résolument scientifiques et se retrouvent à poursuivre en tant qu'ingénieur.

Nous avons également une appréciation du temps et des compétences très dépendant de la proportion croissante de recours à des CDD avec lesquels l'investissement dans le temps ne peut être que différents.

Nous avons enfin une forme de dépréciation des exigences du développement, ce que j'appelle la culture du tombe-en-marche: puisque dans un contexte de laboratoire, beaucoup de personnes en position de responsabilité peuvent ou ont pu écrire des lignes de code, elles ont tendance à minorer les efforts nécessaires pour avoir un code de qualité.

Tout cela pour dire que les attentes et les compétences attendues ou raisonnablement réalisables ne sont pas uniformes, mais dépendent beaucoup de plusieurs variables :

* Trajectoire
* Background
* Culture technologique (java, python, C/C++, PHP, ...)
* Appétence pour le développement plus ou moins marquée

C'est pourquoi je propose d'envisager cette présentation sous deux angles et trois profils

Angle: 
* Développement
* Gestion de projet

Profils
* Compétence annexe / Pratique Occasionnelle
* Compétence principale / Pratique quotidienne
* Expertise

--

=== Que faisons-nous ?

* Nous traduisons des pensées humaines en code executable
* Mais nous essayons aussi de comprendre un code en termes humains
* Cette traduction est imparfaite, car ces deux visions ne sont pas bijectives
* Traduire, c'est trahir

=== Complexité

La situation peut rapidement devenir complexe, surtout si le problème à régler n'est pas lui même simple. 

* La traduction peut saturer nos capacités
** Trop d'éléments à prendre en compte
** Trop de relations, statiques ou dynamiques

//TODO Schéma

* Complexité vs Complication ?
** *_Complexe_* s'oppose à *_simple_* => *_indirecte_*,
** *_Compliqué_* s'oppose à *_facile_* => *_difficile_*.

[NOTE.notes]
--
La construction d'une solution logicielle. Les nombreux éléments en interaction, qui s'influencent mutuellement. De plus il y a plusieurs aspects à prendre en compte: la sécurité, la cohérence de l'application, les domaines métiers, les tests, etc. 
L'un des risques principaux est de perdre de vue ce que l'on souhaite faire, de s'éparpiller, d'être un peu en état de stupeur devant l'ensemble des connaissances à mobiliser.
--

**Il va falloir gérer la complexité**

=== Comment nous assurer que nous le faisons bien ?

* Utiliser les normes qualités 9126
* Nous allons nous limiter à deux aspects
** Capacité fonctionnelle, en tant que réponse aux besoin d'un client, partie de sa satisfaction.
** Maintenabilité

=== Agilité

L'agilité est une démarche qui prend pour partie de ne pas prétendre dès le départ à être exhaustif, mais d'apporter des incréments de fonctionnalités et de s'assurer que le client est heureux.

=== Agilité

Sur le plan purement technique, nous pouvons constater que

* Travail en itération par incrément de fonctionnalité
* Recherche de cycles courts et de feedback client
* Conception (_Software Design_) toujours en évolution
* Une recherche de l'excellence technique
* Une remise en cause et une adaptation permanente

=== TODO transition

=== Maintenabilité

**Ce n'est pas parce qu'un logiciel fonctionne qu'il est bon**

**TODO** mettre ici image du chien

L'essence du développement logiciel, c'est de pouvoir faire évoluer un logiciel, surtout en agilité.

=== Maintenabilité


[%step]
[.left-column]
* Faciliter la *compréhension*
* Faciliter l'*analyse*

[%step]
[.right-column]
* Faciliter la *modification*
* Faciliter les *tests*
* Faciliter l'*assemblage des composants*


[NOTE.notes]
--
* Faciliter la compréhension
** *Que* font les composants ?
** *Comment* le font-il ?
* Faciliter l'analyse
** Trouver *qui* est responsable de *quoi*,
** Évaluer l'*impact* d'une modification,
** *Diagnostiquer* rapidement les *erreurs* en cours d'exécution.
* Faciliter la modification
** *Corriger* des bugs,
** *Améliorer* des parties de code,
*** Meilleures performances
*** Économiser des ressources
** _Le tout sans redouter que cela ne vous éclate à la figure._
* Faciliter les tests
** *Concevoir* des tests,
** *Écrire* des tests,
** Les *exécuter* le plus fréquemment possible.
--

=== Dette technique

Au cours d'un développement, des compromis, des maladresses ou des raccourcis font gagner du temps et des ressources, mais qui pénalisent la maintenabilité de l'application et sa faculté à évoluer.

Métaphore de la dette à rembourser

Pour 10$ de gagner, je devrais rembourser 15$ pour revenir à un niveau acceptable.

//TODO faire un schéma

La dette technique d'une itération (sprint) peut compromettre le sprint suivant (notion de vélocité)

**Il ne peut y avoir d'Agilité sans prise en compte de la dette technique**

// TODO insérer Technical Debt Martin Fowler

**=> Refactoring, outil de gestion de la dette technique**


=== Comment mesurer la dette technique ?

* La dette technique est l'effet délétère de l'écart à ce qu'il aurait été souhaitable de faire.
* Comment définir ce qu'il aurait été souhaitable de faire ?
* Référentiel de bonnes pratiques
** Choix de la communauté 
** Heuristiques propre à chaque écosystème
** Principes reconnus comme universel (Code Clean)
** Les Design Patterns (GoF, GRASP, ...)
** et leurs contraires:
*** Anti patterns
*** Bad smells
* Système d'analyse qualité
* Linters

[NOTE.notes]
--
Les moteurs d'analyse qualité sont des outils très puissants, le plus connu étant sonarqube. Mais il n'est pas forcément nécessaire d'utiliser, encore moins de mettre en oeuvre, un tel système pour avoir une idée des écarts manifestes et corrigeables. Des linters suffisent.
--

== Refactoring : Définition

La gestion de la dette technique passe par le _refactoring_ ou _refactorisation_

* _Refactorisation_:
** Modification de la structure interne d'un logiciel afin de le rendre plus facile à comprendre et moins coûteux à faire évoluer sans changer son comportement observable
* _Refactoriser_: 
** Restructurer un logiciel en appliquant une série de refactorisations sans changer son comportement observable

=== Refactoring : Concepts clef

* Modifications comme objet  
** Comment bien procéder
** La bonne exécution est considérée comme satisfaisante
* Amélioration qualités internes
** => préoccupation du développeur
* Conservations qualités externes
** => ne concerne pas l'utilisateur
**** L'utilisateur ne sait pas que le remaniement a eu lieu
* Consommation de ressources
** => Préoccupation de la gestion de projet
*** Le Product Owner doit comprendre les bénéfices du refactoring 


[NOTE.notes]
--
La grille de lecture du refactoring ne porte pas sur l'exécution d'un programme, car on le suppose suffisamment satisfaisant le temps de procéder à la modification de son code. Le refactoring se concentre la notion de modification du code et ses effets comme objets principaux. 
De même l’ingénierie navale cherche à minimiser l'impact des avaries et des voix d'eau sur un navire, le refactoring cherche à l'impact des modifications sur un code.  
--


=== Refactoring : Objectifs ?

[.simple]
* Faciliter la compréhension
* Améliorer la conception
* Améliorer la confiance
** Rendre le code le plus facile à tester possible
* Faciliter la correction des bogues
* Faciliter les futurs évolutions 


=== Refactoring : Quand ?

[.simple]
* Avant d'ajouter une nouvelle fonctionnalité (_Feature_)
* Quand la mise sous tests est problématique
* Quand le code semble obscure ou ésotérique bien qu'il fonctionne
* Quand des petits défauts sont repérés (_Boy Scout Rules_)
* Lors d'une revue de code ou d'une analyse qualité

=== Quand ne **PAS** refactoriser le code ?

* Quand il est plus facile de le réécrire from scratch
** On ne tire pas sur une ambulance
* Quand il n'y a pas de bonnes raisons de le faire

=== Refactoring : Concrètement ?

* Le refactoring est un ensemble de techniques et d'habitudes, qui vont des plus simples aux plus complexes
* Martin Fowler les a formalisé dans son célèbre ouvrage.

=== Refactoring : Catégories

**Lister les categories**

=== Refactoring : Techniques

**Lister les techniques**

=== Refactoring : une autre approche

* L'esprit plutôt que la lettre
** Avoir un fil conducteur plutôt qu'un catalogue
** Pertinence variable
*** Techniques moins cruciales grâce aux outils existants
**** IDE, linters
* Objectifs
** Développeuses et développeurs
*** Lever le nez du guidon
*** Prendre de la hauteur
** Chef(fes) de projet
** Comprendre l'importance du refactoring
** Devenir l'avocat 

=== Une autre approche

* Approche selon trois axes
** Cognitif
** Conception
** Testabilité

== Agenda

**Ici décrire l'agenda**


== Test 101

Un rapide rappel sur les tests automatisés

== Cognitif

Le cerveau premier compilateur

défaut

**Insérer slides classiques**

== Ecriture 

=== Empilement de ligne de codes

=== Lecture et règles de nommage

=== Exercice de réécriture

=== Lecture et niveaux d'importance

**Exemples star treck**

== Améliorer la conception

* _Software Design_
** Traduction sous forme de code d'une solution à un problème humain.
* Ensemble de décisions 
** représentation et de structuration des données et des traitements
**  Pour satisfaire aux critères de Qualité Logicielle




[NOTE.notes]
--
Architecture logicielle vs conception logicielle.
La différence entre les deux peut être plus ou moins nette, notamment en fonction de la complexité et la taille du logicielle.

Nous retiendrons que l'architecture logicielle est une vision de la solution logicielle à haut-niveau, aussi agnostique et indépendante de l'écosystème (langage, framework) que possible.
La conception logicielle s'attache plus à la structuration du code, des données et des traitements, la définitions des entités et l'utilisation des mécanismes du paradigme utilisé (OOP, fonctionnel, impératif, ...) 

Dans certaines situations, le framework sous-jacent est tellement invasif qu'il à tendance à contraindre l'architecture logicielle.

Nous ne nous étendrons pas sur la pertinence ou non de ce mode de fonctionnement.
--

=== Amélioration dans le cadre du refactoring

Dans le cadre du refactoring, nous partons d'une situation donnée

* Conservation du comportement observable
** Principalement _Fonctionnel_
** Souvent aussi _Sécurité_ et _Performance_
* Améliorations des aspects internes uniquement
** Gestion de la complexité
** Ne pas verrouiller le futur
*** Réduire la dette technique du passé en gardant un oeil sur l'avenir
** Améliorer le niveau de confiance
*** Rendre le code plus testable pour le rendre plus testé


[NOTE.notes]
--
Le comportement observable, c'est ce que perçoit un utilisateur du système _de l'extérieur_, ce que nous pouvons résumer grossièrement à trois aspects : les fonctionnalités offertes, la sécurité, les performances.

Dans le cadre du refactoring, nous considérons qu'aucune évolution dans ces 3 domaines sont à considérées, même si il est effectivement courant de faire un refactoring pour améliorer les performances ou minimiser la consommation de ressources.

Pour la sécurité dans la conception, cf NSFAW
--  

== Gestion de la complexité

* La complexité sature les capacités du cerveau humain
* Nous sommes plus performants sur de petits modèles qui tiennent dans notre mémoire de travail que sur de gros ensemble

ifdef::show[]
=== Exigences par niveau
A chaque niveau ses exigences

* Élémentaire :
** Un IDE (Integrated Development Editor)
** Un SCM (Source Control Management)
* Compétent : 
** Programmation OOP
** Design Patterns de base
** Tests unitaires
* Avancé
** Analyseur Qualité
** Integration continue

endif::[]